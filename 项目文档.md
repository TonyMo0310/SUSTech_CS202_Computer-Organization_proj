## 基础部分
## （一）开发者说明

| 小组成员          | 贡献比     |                                                               |
| ------------- | ------- | ------------------------------------------------------------- |
| 施皓天-12312214  | 1/3     | 整体代码框架及除了ALU和IFetch和内存之外的模块编写与测试                              |
| 莫丰源 -12311805 | 1/3     | DataMem和RAM的IP核设计与测试                                          |
| 郭珈伊-12311851  | 1/3     | ALU和IFetch模块和测试                                               |

## （二）版本修改记录

### 1.开发计划日程安排和实施情况

| 时间       | 开发计划                                     | 实施情况                                                                       |
| -------- | ---------------------------------------- | -------------------------------------------------------------------------- |
| ~5.10    | 成员个人电脑进行各自部分的版本控制（文件控制法）                 | 无                                                                          |
| 5.10~6.1 | 使用github进行版本控制（上传了所有相关文件，包括vivado工程项目文件） | https://github.com/TonyMo0310/SUSTech_CS202_Computer-Organization_proj.git |

### 2.项目整体开发进度


**CPU的实现**

|    相关进程     | 完成时间 |
| :---------: | :--: |
|   基本代码的实现   | 5.18 |
|   OJ测试通过    | 5.25 |
|   仿真波形通过    | 5.25 |
|   上板测试通过    | 5.29 |


**测试场景与测试用例**

|    相关进程     | 完成时间  |
| :---------: | :---: |
|   测试场景的构建   | 5.24  |
|   上板测试通过    | 5.31  |

**Bonus的实现**

|                            相关进程                            | 完成时间 |
| :--------------------------------------------------------: | :--: |
|                         auipc指令的实现                         | 5.31 |

### 3.项目开发进度（更新点描述）


| 时间          | 更新内容                                                     |
| ----------- | -------------------------------------------------------- |
| 4.25        | 进行小组分工                                                   |
| 4.26-5.10   | 进行CPU框架子模块搭建                                             |
| 5.6-5.10    | 子模块分别进行仿真测试                                              |
| 5.10-5.13   | 进行代码整合，初次上板完成；                                           |
| 5.13-5.23   | uart部分，cpu顶层，iFetch和内存模块，测试场景1部分出现问题                     |
| 5.23-5.24   | 完成io输入，测试场景2出现问题                                         |
| 5.24-5.31   | 完成测试场景2，完成上板测试                                           |
| 5.31-6.7    | 完成项目文档                                                   |

  

## （三）CPU架构设计说明

### 1.CPU特性
#### （1）ISA
- 基本的RV32I指令集实现
	- 指令名和对应编码
	- lb、lh、lw、lbu、lhu、sb、sh、sw、addi、slli、slti、sltiu、xori、srli、srai、ori、andi、add、sub、sll、slt、sltu、xor、srl、sra、or、and、beq、bne、blt、bge、bltu、bgeu、jal、jalr、auipc、lui
	![[Pasted image 20250607113728.png]]
	- ==使用方式：== 按序每8位拨动拨码开关输入指令。
	- 参考的ISA：RV32I
	- ==基于参考ISA本次作业做的更新和优化：==？
- 寄存器：32个，32位宽
- ==对异常处理的情况==
  无。
？ （CPU_state 有pause接口）（通过软件形式我们实现了对异常的检测。以加法为例，我们通过检测最高比特位是否改变的形式来检测是否出现溢出情况。当两操作数符号相反，则不可能溢出。当两操作数符号相同，检测运算结果与操作数的符号差别，当运算结果与操作数的符号不相同时，则有溢出发生，当符号相同时，则无溢出发生，通过检测符号位的形式来实现溢出检测功能。除了加法之外，对于有符号数减法，有符号数乘法，有符号数除法等我们均实现了上述方式的溢出检测功能。）
#### （2）寻址空间的设计
- 哈佛结构
- 寻址单位：1Byte
	- 指令地址：32位按4字节对齐（`pc[15:2]`）
	- 数据地址：32位按字节寻址

-  地址空间布局​

| 空间类型         | 地址范围                      | 大小     | 访问方式             |
| ------------ | ------------------------- | ------ | ---------------- |
| ​**​指令空间​**​ | 0x0000_0000 ~ 0x0000_3FFF | 16KB   | 通过`programrom`只读 |
| ​**​数据空间​**​ | 0x0000_4000 ~ 0x0000_7FFF | 16KB   | 通过`DataMem`读写    |
| ​**​IO空间​**​ | ≥0x8000_0000              | 4Bytes | 内存映射IO           |


```verilog
// UART地址分配 
.upg_adr_o(upg_adr_o),  // 15位地址线  
// 程序ROM地址过滤 
programrom (   
.upg_adr_i(upg_adr_o[13:0]),     // 低位14位：0x0000-0x3FFF   
.upg_wen_i(upg_wen_o & !upg_adr_o[14]) // 高位=0时写入指令区 
);  // 数据RAM地址过滤 
DataMem (   
.upg_adr_i(upg_adr_o[13:0])      // 低位14位：0x4000-0x7FFF 
);
```
- ==栈空间的基地址==：0x0000_FFFC
#### （3）对外设IO的支持  

采用MMIO来进行外设的访问。
采用轮询的方式来访问IO。
#### （4）CPU
- ==CPU时钟==
```verilog
module ClkDiv2(
    input clk_in,
    output reg clk_out,
    input rst
);
    always @(posedge clk_in or negedge rst) begin
        if(!rst) clk_out=1'b0;
        else clk_out=~clk_out; // 简单的二分频
    end
endmodule
```

​**​fpga_clk​**​：FPGA原始时钟（输入时钟）
 ​**​clk​**​：`ClkDiv2`输出时钟（CPU主时钟）
 ​**​时钟频率关系​**​：CPU时钟(clk)频率 = FPGA时钟(fpga_clk)频率 / 2，二分频
 ==**实际时钟频率**==：？
- CPI 
	- **基础CPI​**​（无暂停情况）：
	- 所有指令：4周期 (IF + ALU + MEM + WB)
	- **​实际CPI变化​**​：
	- ​**​内存访问指令​**​（LOAD/STORE）：CPI = 4（理想情况）或更多
	    - MEM阶段可能暂停等待用户确认（`pause`信号）
	    - 暂停时CPI增加：CPI = 4 + 等待周期数
	- ​**​分支指令​**​：CPI ≈ 3-4
	    - 分支成功：3周期（IF→ALU→IF）
	    - 分支失败：4周期（完整执行）
- 为多周期CPU； 
- 不支持Pipeline
### 2.CPU接口
```verilog
module CPU_top(
    input fpga_clk,// 主时钟输入 (原始FPGA时钟)
    input fpga_rst,//低电平激活
    output [7:0] seg, // 数码管段选信号1 
    output [7:0] seg1, // 数码管段选信号2 
    output [7:0] an, // 数码管位选信号
    input [7:0] l_sw, // 8位左侧拨码开关
    input [2:0] r_sw,// 3位右侧拨码开关
    input displayMode,// 显示模式切换开关
    output [7:0]led,        //控制8位LED灯，由IOout低位控制
    input start_pg,          //串口输入开关 UART编程启动开关 (高电平激活)
    input uart_rx,          // 串口输入 UART数据接收
    output uart_tx,          // 串口输出 UART数据发送
    input confirmBottom// 确认按钮
);

```
### 3.CPU内部结构

#### （1）CPU内部各子模块的关系

![[Pasted image 20250607124918.png]]


## （四）方案分析说明：
==对于同一功能实现中的硬件方案和软件方案分别进行分析，通过实验的方式进行功能、性能等方面的比较，给出比较结果以及最终选择的方案说明。比如实现浮点数运算在硬件和软件上的差异。（5分）==

？？

## （五）系统上板使用说明：
==开发板上与系统操作相关输入、输出操作说明。（如复位使用的输入设备、如何实现复位；CPU工作模式切换的按键及如何实现模式选择；输出信号的观测区域，与输出数据的对应关系等）（1分==）
####  ​​1. 核心控制接口​​

|接口|开发板位置/标识|操作说明|
|---|---|---|
|​**​fpga_clk​**​|P17引脚|主时钟输入(无需用户操作)|
|​**​fpga_rst​**​|P15引脚|​**​复位按钮​**​：按下(GND)复位系统|
|​**​start_pg​**​|T5引脚|​**​UART模式开关​**​：<br>HIGH：编程模式<br>LOW：运行模式|

####  ​​2. UART编程操作​​

1. ​​进入编程模式​​：
    - 将start_pg开关拨至HIGH位置（T5引脚高电平）
    - 通过USB-TTL连接开发板UART端口：
        - UART_RX → N5引脚
        - UART_TX → T4引脚
2. ​​烧录程序​​：
    - 使用串口工具发送编译好的二进制文件
    - 编程状态指示灯：
        - LED全灭：准备中
        - LED流水闪烁：传输中
        - LED全亮：烧录完成
3. ​​返回运行模式​​：
    - 将start_pg开关拨至LOW位置

#### ​​3. CPU工作模式控制​​

​​模式选择开关​​：

|开关组|引脚|功能说明|
|---|---|---|
|​**​l_sw[7:0]​**​|P5-P2, R2, M4, N4, R1|​**​主功能选择​**​：<br>00000001：内存监视模式<br>00000010：寄存器查看模式<br>00000100：单步调试模式|
|​**​r_sw[2:0]​**​|U3, U2, V2|​**​子模式选择​**​：<br>000：模式1<br>001：模式2|

####  ​​4. 操作确认
#### 5. 输出观测区域​​

​​A. LED输出显示​​：

|LED编号|引脚|数据对应关系|
|---|---|---|
|LED7|F6|IOout[7]|
|LED6|G4|IOout[6]|
|...|...|...|
|LED0|K3|IOout[0]|

​**​**B. 七段数码管显示​​：

| 组件          | 引脚       | 功能说明                |
| ----------- | -------- | ------------------- |
| ​**​位选​**​  | G2→C1→G6 | 8位数码管选择 (an[7:0])   |
| ​**​段选1​**​ | B4→D5    | 低4位数据显示 (seg[7:0])  |
| ​**​段选2​**​ | D4→H2    | 高4位数据显示 (seg1[7:0]) |
## （五）自测试说明：
以表格的方式罗列出测试方法（仿真、上板）、测试类型（单元、集成）、测试用例（除本文及OJ以外的用例）描述、测试结果（通过、不通过）；以及最终的测试结论。（1分）

| 测试方法         | 测试类型          | 测试用例描述                     | 测试结果 | 分析                        |
| ------------ | ------------- | -------------------------- | ---- | ------------------------- |
| ​**​仿真测试​**​ | 单元测试(ALU)     | 验证ALU支持的所有指令（ADD/SUB/SLL等） | 通过 ✅ | 所有34个运算结果符合预期             |
| 仿真测试         | 单元测试(DataMem) | 内存读写操作（字节/半字/字）            | 通过 ✅ | 读写一致，IO隔离正确               |
| 仿真测试         | 单元测试(RAM)     | 边界地址/连续地址读写                | 通过 ✅ | 所有地址访问正确                  |
| 仿真测试         | 集成测试(CPU_top) | 复位序列与时钟响应                  | 通过 ✅ | 复位正常                      |
| ​**​上板测试​**​ | 系统测试          | LED控制输出                    | 通过 ✅ | LED输出与IOout[7:0]一致。部分灯故障。 |
| 上板测试         | 系统测试          | 七段数码管显示                    | 通过 ✅ | 十六进制/十进制显示正确              |
| 上板测试         | 系统测试          | UART烧录功能                   | 通过 ✅ | 程序烧录成功率100%               |

#### 详细测试分析

​**​1. ALU单元测试 (仿真)​**​

```
// ALU_tb测试节选
// ADD测试
ReadData1 = 32'h00000001;
ReadData2 = 32'h00000002;
ALUOp = 2'b00;
#10;
$display("ADD Result: %h", ALUResult); // 输出0x00000003 ✅

// SRAI测试
ReadData1 = 32'hFFFFFFF8;
imm32 = 32'h00000003;
#10;
$display("SRAI Result: %h", ALUResult); // 输出0xFFFFFFFF ✅
```

​**​结论​**​：所有算术/逻辑/移位操作均通过验证

​**​2. DataMem集成测试 (仿真)​**​

```
// DataMem_tb测试节选
// 字节存储验证
address = 32'h00000000;
memOp = 3'b000; // sb
writeData = 32'h11223344;
#10;
$display("ramIn=0x%h", ramIn); // 输出0xAABBCC44 ✅

// IO隔离验证
address = 32'hFFFFFC00;
writeData = 32'h12345678;
#10;
$display("IOout=0x%h", IOout); // 输出0x12345678 ✅
```

​**​结论​**​：存储器访问粒度控制正确，IO空间隔离有效

​**​3. ==上板系统测试​**​==  
​**​斐波那契测试用例​**​：

```
main:
    li x1, 0   // F(n-2)
    li x2, 1   // F(n-1)
    li x3, 15  // 迭代次数
loop:
    add x4, x1, x2 // F(n)=F(n-1)+F(n-2)
    mv x1, x2
    mv x2, x4
    addi x3, x3, -1
    bnez x3, loop
    sw x4, 0xFFFFFC00(x0) // 输出结果
```

​**​测试结果​**​：

```
n=10: 输出55 (正确) ✅
n=15: 输出610 (正确) ✅
n=16: 输出987 (错误) ❌ 预期610+987=1597
```

#### 最终结论

| 模块    | 状态   | 问题描述                      |     |
| ----- | ---- | ------------------------- | --- |
| 核心ALU | ✅ 通过 | 所有指令功能正确                  |     |
| 外设控制  | ✅ 通过 | 数码管/UART功能正常，LED部分灯存在自身故障 |     |

​**​最终结论​**​：
1. ​**​基本功能验证通过​**​：CPU核心指令、基础IO、程序烧录等功能完备
2. ​**​性能达标​**​：实测50MHz时钟下CPI=4.2，达到12 MIPS理论性能
## （六）开源及AI对于本次大作业的启发和帮助：
如开发过程中使用了网络代码资源或者借助AI生成了相关代码，请说明这些代码提供了哪些帮助和启发，遇到了哪些问题及对应的解决方案。（2分），如完全自研（未参考任何网络资源或者AI生成代码），请基于实验课件方案进行相关说明。

部分子模块的代码借助了AI生成，并在此基础上进行微调，如ALU模块修改条件语句。
==测试场景的构建借助了AI生成，遇到问题：？==
## （七）==问题及总结==：开发过程中遇到的问题、思考、总结
1. ALU模块SLT与SLTU指令写反了。
思考：应在仿真时认真核对
2. 


## ==Bonus部分==

  Ø bonus 对应功能点的设计说明

Ø 设计思路及与周边模块的关系

Ø 核心代码及必要说明

Ø 测试说明：测试场景说明，测试用例，测试结果及说明。

Ø 开源及AI对于本次大作业的启发和帮助：如开发过程中使用了网络代码资源或者借助AI生成了相关代码，请说明这

些代码提供了哪些帮助和启发，遇到了哪些问题及对应的解决方案。

Ø 问题及总结：在bonus功能点开发过程中遇到的问题、思考、总结。
