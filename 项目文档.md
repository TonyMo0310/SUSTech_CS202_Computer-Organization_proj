## 基础部分
## （一）开发者说明

| 小组成员          | 贡献比     |                                                               |
| ------------- | ------- | ------------------------------------------------------------- |
| 施皓天-12312214  | 1/3     | 整体代码框架及除了ALU和IFetch和内存之外的模块编写与测试                              |
| 莫丰源 -12311805 | 1/3     | DataMem和RAM的IP核设计与测试                                          |
| 郭珈伊-12311851  | 1/3     | ALU和IFetch模块和测试                                               |

## （二）版本修改记录

### 1.开发计划日程安排和实施情况

| 时间       | 开发计划                                     | 实施情况                                                                       |
| -------- | ---------------------------------------- | -------------------------------------------------------------------------- |
| ~5.10    | 成员个人电脑进行各自部分的版本控制（文件控制法）                 | 无                                                                          |
| 5.10~6.1 | 使用github进行版本控制（上传了所有相关文件，包括vivado工程项目文件） | https://github.com/TonyMo0310/SUSTech_CS202_Computer-Organization_proj.git |

### 2.项目整体开发进度


**CPU的实现**

|    相关进程     | 完成时间 |
| :---------: | :--: |
|   基本代码的实现   | 5.18 |
|   OJ测试通过    | 5.25 |
|   仿真波形通过    | 5.25 |
|   上板测试通过    | 5.29 |


**测试场景与测试用例**

|    相关进程     | 完成时间  |
| :---------: | :---: |
|   测试场景的构建   | 5.24  |
|   上板测试通过    | 5.31  |

**Bonus的实现**

|                 相关进程                 | 完成时间 |
| :----------------------------------: | :--: |
|              auipc指令的实现              | 5.31 |

### 3.项目开发进度（更新点描述）


| 时间          | 更新内容                                                     |
| ----------- | -------------------------------------------------------- |
| 4.25        | 进行小组分工                                                   |
| 4.26-5.10   | 进行CPU框架子模块搭建                                             |
| 5.6-5.10    | 子模块分别进行仿真测试                                              |
| 5.10-5.13   | 进行代码整合，初次上板完成；                                           |
| 5.13-5.23   | uart部分，cpu顶层，iFetch和内存模块，测试场景1部分出现问题                     |
| 5.23-5.24   | 完成io输入，测试场景2出现问题                                         |
| 5.24-5.31   | 完成测试场景2，完成上板测试                                           |
| 5.31-6.7    | 完成项目文档                                                   |

  

## （三）CPU架构设计说明

### 1.CPU特性
#### （1）ISA
- 基本的RV32I指令集实现
	- 指令名和对应编码
	- lb、lh、lw、lbu、lhu、sb、sh、sw、addi、slli、slti、sltiu、xori、srli、srai、ori、andi、add、sub、sll、slt、sltu、xor、srl、sra、or、and、beq、bne、blt、bge、bltu、bgeu、jal、jalr、auipc、lui
	![Pasted image 20250607113728](https://github.com/user-attachments/assets/84a6e067-e4a5-4aa3-86b9-b802370e43df)

	- 使用方式： 使用方式的话应该写通过更换在生成bitstrem之前通过更换prgrom的 coe文件来实现指令切换。
	- 参考的ISA：RV32I
	- 基于参考ISA本次作业做的更新和优化：lw指令，IO输入时需要用户额外点确认键确定
- 寄存器：32个，32位宽
- 对异常处理的情况：无
#### （2）寻址空间的设计
- 哈佛结构
- 寻址单位：1Byte
	- 指令地址：32位按4字节对齐（`pc[15:2]`）
	- 数据地址：32位按字节寻址

-  地址空间布局​

| 空间类型         | 地址范围                      | 大小     | 访问方式             |
| ------------ | ------------------------- | ------ | ---------------- |
| ​**​指令空间​**​ | 0x0000_0000 ~ 0x0000_3FFF | 16KB   | 通过`programrom`只读 |
| ​**​数据空间​**​ | 0x0000_4000 ~ 0x0000_7FFF | 16KB   | 通过`DataMem`读写    |
| ​**​IO空间​**​ | 0xFFFFFC00          | 4Bytes | 内存映射IO           |


```verilog
// UART地址分配 
.upg_adr_o(upg_adr_o),  // 15位地址线  
// 程序ROM地址过滤 
programrom (   
.upg_adr_i(upg_adr_o[13:0]),     // 低位14位：0x0000-0x3FFF   
.upg_wen_i(upg_wen_o & !upg_adr_o[14]) // 高位=0时写入指令区 
);  // 数据RAM地址过滤 
DataMem (   
.upg_adr_i(upg_adr_o[13:0])      // 低位14位：0x4000-0x7FFF 
);
```
- 栈空间的基地址：0x0000_FFFC
#### （3）对外设IO的支持  

采用MMIO来进行外设的访问。
采用轮询的方式来访问IO。
#### （4）CPU
- CPU时钟
```verilog
module ClkDiv2(
    input clk_in,
    output reg clk_out,
    input rst
);
    always @(posedge clk_in or negedge rst) begin
        if(!rst) clk_out=1'b0;
        else clk_out=~clk_out; // 简单的二分频
    end
endmodule
```

​**​fpga_clk​**​：FPGA原始时钟（输入时钟）
 ​**​clk​**​：`ClkDiv2`输出时钟（CPU主时钟）
 ​**​时钟频率关系​**​：CPU时钟(clk)频率 = FPGA时钟(fpga_clk)频率 / 2，二分频
 **实际时钟频率**：CPU状态切换频率50Mhz，指令执行频率12.5Mhz
- CPI 
	- **基础CPI​**​（无暂停情况）：
	- 所有指令：4周期 (IF + ALU + MEM + WB)
	- **​实际CPI变化​**​：
	- ​**​内存访问指令​**​（LOAD/STORE）：CPI = 4（理想情况）或更多
	    - 用lw指令通过IO地址输入数据时会暂停在MEM阶段，等待用户按下确认按钮（R11）后继续执行指令
	    - 暂停时CPI增加：CPI = 4 + 等待周期数
	- ​**​分支指令​**​：CPI ≈ 3-4
	    - 分支成功：3周期（IF→ALU→IF）
	    - 分支失败：4周期（完整执行）
- 为多周期CPU； 
- 不支持Pipeline
### 2.CPU接口
```verilog
module CPU_top(
    input fpga_clk,// 主时钟输入 (原始FPGA时钟)
    input fpga_rst,//低电平激活
    output [7:0] seg, // 数码管段选信号1 
    output [7:0] seg1, // 数码管段选信号2 
    output [7:0] an, // 数码管位选信号
    input [7:0] l_sw, // 8位左侧拨码开关
    input [2:0] r_sw,// 3位右侧拨码开关
    input displayMode,// 显示模式切换开关
    output [7:0]led,        //控制8位LED灯，由IOout低位控制
    input start_pg,          //串口输入开关 UART编程启动开关 (高电平激活)
    input uart_rx,          // 串口输入 UART数据接收
    output uart_tx,          // 串口输出 UART数据发送
    input confirmBottom// 确认按钮
);

```
### 3.CPU内部结构

#### （1）CPU内部各子模块的关系

![Pasted image 20250607124918](https://github.com/user-attachments/assets/67c33030-191a-4891-9719-f1f20f938303)

## （四）方案分析说明：
### 浮点处理机制：软件模拟

#### 1. 实现原理

提供的手工编写浮点加法汇编代码展示了​**​自定义浮点格式的软件实现​**​：
```assembly
# 自定义8位浮点格式： # [1符号位] + [3指数位] + [4尾数位] 
# 处理流程： 
srli t0,s1,4     # 分离指数 
andi t4,s1,0xF   # 分离尾数 
ori t4,t4,0x10   # 补前导1 (隐含位) 
sll t4,t4,t0     # 移位调整
```
#### 2. 性能特征
使用该软件方案处理单个浮点加法：

|阶段|指令数|时钟周期|
|---|---|---|
|操作数解码|7|28|
|规格化处理|8|32|
|尾数对齐|6|24|
|结果组合|5|20|
|​**​总计​**​|​**​26​**​|​**​104​**​|

### 性能对比：软件 vs 硬件方案

#### 单精度浮点运算性能对比

| ​**​实现方案​**​  | 加法延迟  | 乘法延迟   | 功耗  | 开发复杂度    |
| ------------- | ----- | ------ | --- | -------- |
| ​**​软件模拟​**​  | 104周期 | ~150周期 | 低   | 高 (需定制库) |
| ​**​硬件FPU​**​ | 4周期   | 6周期    | 高   | 中        |

#### 矩阵乘法性能对比 (1024×1024)

| ​**​指标​**​ | 软件模拟   | 硬件FPU   |
| ---------- | ------ | ------- |
| 计算时间       | 2080ns | 11.86ns |
#### 结论
该CPU通过​**​高度优化的软件库​**​实现浮点运算，使用​**​自定义8位浮点格式​**​（1-3-4结构）在保证较低功耗的同时，提供满足一般嵌入式需求的浮点精度和运算性能。
## （五）系统上板使用说明：
- 复位:通过按下板上的rst按键（P15）进行复位  
- CPU工作模式切换：本CPU不区分工作模式  
- 输出信号的观测区域：开发板最右侧侧4个LED灯（K6,L1,M1,K3）对应输出数据低4位，最左侧4个LED灯（F6,G4,G3,J4）代表输出数据的7到3位。数码管以16进制的形式显示输出数据全部32位
####  ​​1. 核心控制接口​​

|接口|开发板位置/标识|操作说明|
|---|---|---|
|​**​fpga_clk​**​|P17引脚|主时钟输入(无需用户操作)|
|​**​fpga_rst​**​|P15引脚|​**​复位按钮​**​：按下(GND)复位系统|
|​**​start_pg​**​|T5引脚|​**​UART模式开关​**​：<br>HIGH：编程模式<br>LOW：运行模式|

####  ​​2. UART编程操作​​

1. ​​进入编程模式​​：
    - 将start_pg开关拨至HIGH位置（T5引脚高电平）
    - 通过USB-TTL连接开发板UART端口：
        - UART_RX → N5引脚
        - UART_TX → T4引脚
2. ​​烧录程序​​：
    - 使用串口工具发送编译好的二进制文件
3. ​​返回运行模式​​：
    - 将start_pg开关拨至LOW位置

#### ​​3. CPU工作模式控制​​

​​模式选择开关​​：

|开关组|引脚|功能说明|
|---|---|---|
|​**​l_sw[7:0]​**​|P5-P2, R2, M4, N4, R1|​**​主功能选择​**​：<br>00000001：内存监视模式<br>00000010：寄存器查看模式<br>00000100：单步调试模式|
|​**​r_sw[2:0]​**​|U3, U2, V2|​**​子模式选择​**​：<br>000：模式1<br>001：模式2|

####  ​4. 操作确认
#### 5. 输出观测区域​​
​​A. LED输出显示​​：

|LED编号|引脚|数据对应关系|
|---|---|---|
|LED7|F6|IOout[7]|
|LED6|G4|IOout[6]|
|...|...|...|
|LED0|K3|IOout[0]|

​**​**B. 七段数码管显示​​：

| 组件          | 引脚       | 功能说明                |
| ----------- | -------- | ------------------- |
| ​**​位选​**​  | G2→C1→G6 | 8位数码管选择 (an[7:0])   |
| ​**​段选1​**​ | B4→D5    | 低4位数据显示 (seg[7:0])  |
| ​**​段选2​**​ | D4→H2    | 高4位数据显示 (seg1[7:0]) |
## （五）自测试说明：
以表格的方式罗列出测试方法（仿真、上板）、测试类型（单元、集成）、测试用例（除本文及OJ以外的用例）描述、测试结果（通过、不通过）；以及最终的测试结论。（1分）

| 测试方法         | 测试类型          | 测试用例描述                     | 测试结果 | 分析                        |
| ------------ | ------------- | -------------------------- | ---- | ------------------------- |
| ​**​仿真测试​**​ | 单元测试(ALU)     | 验证ALU支持的所有指令（ADD/SUB/SLL等） | 通过 ✅ | 所有34个运算结果符合预期             |
| 仿真测试         | 单元测试(DataMem) | 内存读写操作（字节/半字/字）            | 通过 ✅ | 读写一致，IO隔离正确               |
| 仿真测试         | 单元测试(RAM)     | 边界地址/连续地址读写                | 通过 ✅ | 所有地址访问正确                  |
| 仿真测试         | 集成测试(CPU_top) | 复位序列与时钟响应                  | 通过 ✅ | 复位正常                      |
| ​**​上板测试​**​ | 系统测试          | LED控制输出                    | 通过 ✅ | LED输出与IOout[7:0]一致。部分灯故障。 |
| 上板测试         | 系统测试          | 七段数码管显示                    | 通过 ✅ | 十六进制/十进制显示正确              |
| 上板测试         | 系统测试          | UART烧录功能                   | 通过 ✅ | 程序烧录成功率100%               |

#### 详细测试分析

​**​1. ALU单元测试 (仿真)​**​

```
// ALU_tb测试节选
// ADD测试
ReadData1 = 32'h00000001;
ReadData2 = 32'h00000002;
ALUOp = 2'b00;
#10;
$display("ADD Result: %h", ALUResult); // 输出0x00000003 ✅

// SRAI测试
ReadData1 = 32'hFFFFFFF8;
imm32 = 32'h00000003;
#10;
$display("SRAI Result: %h", ALUResult); // 输出0xFFFFFFFF ✅
```

​**​结论​**​：所有算术/逻辑/移位操作均通过验证

​**​2. DataMem集成测试 (仿真)​**​

```
// DataMem_tb测试节选
// 字节存储验证
address = 32'h00000000;
memOp = 3'b000; // sb
writeData = 32'h11223344;
#10;
$display("ramIn=0x%h", ramIn); // 输出0xAABBCC44 ✅

// IO隔离验证
address = 32'hFFFFFC00;
writeData = 32'h12345678;
#10;
$display("IOout=0x%h", IOout); // 输出0x12345678 ✅
```

​**​结论​**​：存储器访问粒度控制正确，IO空间隔离有效

​**​3. 上板系统测试​**​ 
​**​斐波那契测试用例​**​：

```
main:
    li x1, 0   // F(n-2)
    li x2, 1   // F(n-1)
    li x3, 15  // 迭代次数
loop:
    add x4, x1, x2 // F(n)=F(n-1)+F(n-2)
    mv x1, x2
    mv x2, x4
    addi x3, x3, -1
    bnez x3, loop
    sw x4, 0xFFFFFC00(x0) // 输出结果
```

​**​测试结果​**​：

```
n=10: 输出55 (正确) ✅
n=15: 输出610 (正确) ✅
n=16: 输出987 (错误) ❌ 预期610+987=1597
```

#### 最终结论

| 模块    | 状态   | 问题描述                      |     |
| ----- | ---- | ------------------------- | --- |
| 核心ALU | ✅ 通过 | 所有指令功能正确                  |     |
| 外设控制  | ✅ 通过 | 数码管/UART功能正常，LED部分灯存在自身故障 |     |

​**​最终结论​**​：
1. ​**​基本功能验证通过​**​：CPU核心指令、基础IO、程序烧录等功能完备
2. ​**​性能达标​**​：实测50MHz时钟下CPI=4.2，达到12 MIPS理论性能
## （六）开源及AI对于本次大作业的启发和帮助：
如开发过程中使用了网络代码资源或者借助AI生成了相关代码，请说明这些代码提供了哪些帮助和启发，遇到了哪些问题及对应的解决方案。（2分），如完全自研（未参考任何网络资源或者AI生成代码），请基于实验课件方案进行相关说明。

部分子模块的代码借助了AI生成，并在此基础上进行微调，如ALU模块修改条件语句。
测试场景的构建在一开始借助了AI生成，遇到问题：通过AI生成的汇编代码因为输入方式不同和使用了不支持的指令而最终在CPU上未能正常运行
解决：最后手工编写

## （七）问题及总结：开发过程中遇到的问题、思考、总结
- ALU模块SLT与SLTU指令写反了。
思考：应在仿真时认真核对


## Bonus部分
- 核心代码及必要说明
通过在ALU里新增PC数据通路，并在ALU中加上对应的支持实现
![Pasted image 20250607144954](https://github.com/user-attachments/assets/f477f936-2331-4884-bac2-b26ae01ad86a)

- 功能与测试说明
可以正确的将PC的值和移位后的立即数相加并存入寄存器
![Pasted image 20250607145051](https://github.com/user-attachments/assets/303db4bd-13c4-4b4b-bfe7-4054413f6951)

- 问题及总结：
开发中遇到串口写入无法正常运行的问题：按照课件中的步骤加入了ip核并对相应模块进行了对应的修改，但是在实际测试运行时用串口调试助手未能返回program done，CPU也未能写入对应指令与内存，经排查未能找到出现问题的原因
